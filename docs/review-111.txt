.. out of a total of 9 incidences.


## Undocumented use of a 3rd Party / external service

Plugins are permitted to require the use of third party/external services as long as they are clearly documented.

When your plugin reach out to external services, you must disclose it. This is true even if you are the one providing that service.

You are required to document it in a clear and plain language, so users are aware of: what data is sent, why, where and under which conditions.

To do this, you must update your readme file to clearly explain that your plugin relies on third party/external services, and include at least the following information for each third party/external service that this plugin uses:

    What the service is and what it is used for.
    What data is sent and when.
    Provide links to the service's terms of service and privacy policy.

Remember, this is for your own legal protection. Use of services must be upfront and well documented. This allows users to ensure that any legal issues with data transmissions are covered.

Example:

== External services ==

This plugin connects to an API to obtain weather information, it's needed to show the weather information and forecasts in the included widget.

It sends the user's location every time the widget is loaded (If the location isn't available and/or the user hasn't given their consent, it displays a configurable default location).
This service is provided by "PRT Weather INC": terms of use, privacy policy.



Example(s) from your plugin:

# Domain(s) not mentioned in the readme file.
frontend/templates/receipt.php:409 <img src="https://api.qrserver.com/v1/create-qr-code/?size=100x100&data=<?php echo urlencode(get_permalink($donation->campaign_id)); ?>"




## Saving data in the plugin folder and/or asking users to edit/write to plugin.

We cannot accept a plugin that forces (or tells) users to edit the plugin files in order to function, or saves data in the plugin folder.

Plugin folders are deleted when upgraded, so using them to store any data is problematic. Also bear in mind, any data saved in a plugin folder is accessible by the public. This means anyone can read it and use it without the site-owner‚Äôs permission.

It is preferable that you save your information to the database, via the Settings API, especially if it‚Äôs privileged data.

If that‚Äôs not possible, because you‚Äôre uploading media files, you should use the media uploader.

If you can‚Äôt do either of those, you must save the data outside the plugins folder. We recommend using the uploads directory, creating a folder there with the slug of your plugin as name, as that will make your plugin compatible with multisite and other one-off configurations.

Please refer to the following links:

    https://developer.wordpress.org/plugins/settings/
    https://developer.wordpress.org/reference/functions/media_handle_upload/
    https://developer.wordpress.org/reference/functions/wp_handle_upload/
    https://developer.wordpress.org/reference/functions/wp_upload_dir/


Example(s) from your plugin:

includes/services/donation.php:28 file_put_contents(WP_CONTENT_DIR . '/wpd-debug.log', $log, FILE_APPEND);
# ‚Ü≥ Detected: WP_CONTENT_DIR




## Review: Missing permission_callback in REST API Route

When using register_rest_route() or wp_register_ability() to define custom REST API endpoints, it is crucial to include a proper permission_callback .

üîí This callback function ensures that only authorized users can access or modify data through your endpoint.

Code example, checking that the user can change options:

register_rest_route( 'donasai/v1', '/my-endpoint', array(
    'methods' => 'GET',
    'callback' => 'donasai_callback_function',
    'permission_callback' => function() {
        return current_user_can( 'manage_options' );
    }
) );


Please check the register_rest_route() documentation and the current_user_can() documentation.

‚úÖ When a permission_callback is NOT Required:

There are valid use cases for public endpoints, such as publicly available data (e.g., posts, public metadata) or endpoints designed for unauthenticated access (e.g., fetching public stats or information).

In these cases, you should use __return_true as the permission_callback to indicate that the endpoint is intentionally public.

üîí When a permission_callback IS Required:

For endpoints that involve sensitive data or actions (e.g., getting not public data, creating, updating, or deleting content).

In these cases, you should always implement proper permission checks.

Possible cases found on this plugin's code:

includes/api/fundraisers-controller.php:23 register_rest_route('wpd/v1', '/fundraisers', array(
    'methods' => 'GET',
    'callback' => 'wpd_api_get_fundraisers',
    // Public route for leaderboard? Or admin only?
    // If accessing specific user stats -> auth required.
    // If accessing leaderboard -> public.
    'permission_callback' => function () {
        // Public for Leaderboard (campaign_id)
        // Private for 'mine' (checked in callback)
        // Admin for full list (checked in callback)
        return true;
    },
));
includes/api/campaigns-controller.php:30 register_rest_route('wpd/v1', '/campaigns/(?P<id>\\d+)/donors', array('methods' => 'GET', 'callback' => 'wpd_api_get_campaign_donors', 'permission_callback' => function () {
    return true;
    // Public endpoint for listing donors
}));
includes/api/campaigns-controller.php:12 register_rest_route('wpd/v1', '/campaigns/(?P<id>\\d+)/donate', array('methods' => 'POST', 'callback' => 'wpd_api_create_donation', 'permission_callback' => function () {
    return true;
    // Public endpoint for creating donations
}));

Example(s) from your plugin:

includes/functions-frontend.php:475 $pass1 = isset($_POST['pass1']) ? wp_unslash($_POST['pass1']) : ''; // phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized
 -----> $pass1 = isset($_POST['pass1']) ? wp_unslash($_POST['pass1']) : ''
# ‚Ü≥ Line 494: wp_update_user($user_data);
# ‚Ü≥ Line 509: include WPD_PLUGIN_PATH . 'frontend/templates/profile.php';
# ‚Ü≥ Line 509: include WPD_PLUGIN_PATH . 'frontend/templates/profile.php';
includes/services/donation.php:129 $donation_data = apply_filters('wpd_donation_data_before_insert', array(
'campaign_id' => $campaign_id,
'user_id' => $user_id,
'amount' => $amount,
'name' => $name,
'email' => $email,
'phone' => $phone,
'note' => $note,
'is_anonymous' => $is_anon,
'fundraiser_id' => $fundraiser_id,
'subscription_id' => 0, // Default
'metadata' => json_encode($metadata),
), $_POST);
includes/metabox.php:272 $banks_post = wp_unslash($_POST['wpd_campaign_banks']);
# ‚Ü≥ Line 273: $banks = array_map(function ($val) {
return sanitize_text_field($val);
}, $banks_post);
includes/functions-frontend.php:476 $pass2 = isset($_POST['pass2']) ? wp_unslash($_POST['pass2']) : ''; // phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized
# ‚Ü≥ Line 509: include WPD_PLUGIN_PATH . 'frontend/templates/profile.php';
includes/functions-frontend.php:558 $uploadedfile = isset($_FILES['proof_file']) ? $_FILES['proof_file'] : null; // phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized
 -----> $uploadedfile = isset($_FILES['proof_file']) ? $_FILES['proof_file'] : null
# ‚Ü≥ Line 607: include WPD_PLUGIN_PATH . 'frontend/templates/confirmation-form.php';
includes/functions-frontend.php:542 $amount_post = isset($_POST['amount']) ? wp_unslash($_POST['amount']) : '0'; // phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized
 -----> $amount_post = isset($_POST['amount']) ? wp_unslash($_POST['amount']) : '0'
# ‚Ü≥ Line 607: include WPD_PLUGIN_PATH . 'frontend/templates/confirmation-form.php';



‚úîÔ∏è You can check this using Plugin Check.


## Processing the whole input

We strongly recommend you never attempt to process the whole $_POST/$_REQUEST/$_GET stack. This makes your plugin slower as you're needlessly cycling through data you don't need. Instead, you should only be attempting to process the items within that are required for your plugin to function.

Example(s) from your plugin:

includes/services/donation.php:141 ), $_POST);




## Variables and options must be escaped when echo'd

Much related to sanitizing everything, all variables that are echoed need to be escaped when they're echoed, so it can't hijack users or (worse) admin screens. There are many esc_*() functions you can use to make sure you don't show people the wrong data, as well as some that will allow you to echo HTML safely.

At this time, we ask you escape all $-variables, options, and any sort of generated data when it is being echoed. That means you should not be escaping when you build a variable, but when you output it at the end. We call this 'escaping late.'

Besides protecting yourself from a possible XSS vulnerability, escaping late makes sure that you're keeping the future you safe. While today your code may be only outputted hardcoded content, that may not be true in the future. By taking the time to properly escape when you echo, you prevent a mistake in the future from becoming a critical security issue.

This remains true of options you've saved to the database. Even if you've properly sanitized when you saved, the tools for sanitizing and escaping aren't interchangeable. Sanitizing makes sure it's safe for processing and storing in the database. Escaping makes it safe to output.

Also keep in mind that sometimes a function is echoing when it should really be returning content instead. This is a common mistake when it comes to returning JSON encoded content. Very rarely is that actually something you should be echoing at all. Echoing is because it needs to be on the screen, read by a human. Returning (which is what you would do with an API) can be json encoded, though remember to sanitize when you save to that json object!

There are a number of options to secure all types of content (html, email, etc). Yes, even HTML needs to be properly escaped.

https://developer.wordpress.org/apis/security/escaping/

Remember: You must use the most appropriate functions for the context. There is pretty much an option for everything you could echo. Even echoing HTML safely.

Example(s) from your plugin:

frontend/templates/campaign-single.php:769 fetch('<?php echo esc_url_raw(get_rest_url(null, 'wpd/v1/campaigns/')); ?>' + campaignId + '/donors?page=' + page + '&per_page=<?php echo esc_js($per_page_limit); ?>')
 -----> echo esc_url_raw(get_rest_url(null, 'wpd/v1/campaigns/'));
includes/functions-frontend.php:185 wp_add_inline_style('donasai-frontend', $custom_css);
# ‚Ü≥ Detected origin: ...    --wpd-primary: {$primary_color};                 --wpd-primary-rgb: {$primary_rgb};                 --wpd-btn: {$button_color};                 --wpd-radius: {$radius};                 -...
# ‚Ü≥ Remember to ALWAYS escape as LATE as possible as with a PROPER function for the context.




Note: We know this is confusing, the esc_url_raw function is not an escaping function, but a sanitizing function similar to sanitize_url . Specifically it is used to sanitize a URL for use in a database or a redirection.

The appropriate function to escape a URL is esc_url .

Example(s) from your plugin:

frontend/templates/campaign-single.php:769 fetch('<?php echo esc_url_raw(get_rest_url(null, 'wpd/v1/campaigns/')); ?>' + campaignId + '/donors?page=' + page + '&per_page=<?php echo esc_js($per_page_limit); ?>')
 -----> esc_url_raw(get_rest_url(null, 'wpd/v1/campaigns/'))



‚úîÔ∏è You can check this using Plugin Check.


## Generic function/class/define/namespace/option names

All plugins must have unique function names, namespaces, defines, class and option names. This prevents your plugin from conflicting with other plugins or themes. We need you to update your plugin to use more unique and distinct names.

A good way to do this is with a prefix. For example, if your plugin is called "Donasai ‚Äì Platform Donasi & Penggalangan Dana" then you could use names like these:

    function dona82pl_save_post(){ ... }
    class DONA82PL_Admin { ... }
    update_option( 'dona82pl_options', $options );
    register_setting( 'dona82pl_settings', 'dona82pl_user_id', ... );
    define( 'DONA82PL_PLUGIN_DIR', plugin_dir_path( __FILE__ ) );
    global $dona82pl_options;
    add_action('wp_ajax_dona82pl_save_data', ... );
    namespace hadiedanker\donasai;


Example(s) from your plugin:

includes/api/donations-controller.php:482 $query = $wpdb->prepare(
"SELECT * FROM {$table_name} ORDER BY created_at DESC LIMIT %d OFFSET %d",
$per_page,
$offset
);
includes/api/donations-controller.php:455 $where_sql = $query_parts['where'];
includes/api/donations-controller.php:476 $query = $wpdb->prepare(
"SELECT * FROM {$table_name} WHERE " . $where_sql . " ORDER BY created_at DESC LIMIT %d OFFSET %d",
$args
);
includes/api/donations-controller.php:489 $results = $wpdb->get_results($query); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared
 -----> $wpdb->get_results($query)
# There is a call to a wpdb::prepare() function, but it's not in the same execution context as the query call.
# You cannot add variables like "$query_parts['where']" directly to the SQL query.
# Using wpdb::prepare($query, $args) you will need to include placeholders for each variable within the query and include the variables in the second parameter.

includes/api/donations-controller.php:463 $count_query = "SELECT COUNT(*) FROM {$table_name}"; // phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared
 -----> "SELECT COUNT(*) FROM {$table_name}"
includes/api/donations-controller.php:455 $where_sql = $query_parts['where'];
includes/api/donations-controller.php:461 $count_query = $wpdb->prepare("SELECT COUNT(*) FROM {$table_name} WHERE {$where_sql}", $args);
includes/api/donations-controller.php:465 $total_items = (int) $wpdb->get_var($count_query); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared
 -----> $wpdb->get_var($count_query)
# There is a call to a wpdb::prepare() function, but it's not in the same execution context as the query call.
# You cannot add variables like "$query_parts['where']" directly to the SQL query.
# Using wpdb::prepare($query, $args) you will need to include placeholders for each variable within the query and include the variables in the second parameter.

